#!/bin/bash

os_check() {
    if [ "$PIHOLE_SKIP_OS_CHECK" != true ]; then
        # This function gets a list of supported OS versions from a TXT record at versions.pi-hole.net
        # and determines whether or not the script is running on one of those systems
        local remote_os_domain valid_os valid_version valid_response detected_os detected_version display_warning cmdResult digReturnCode response
        local piholeNameserver="@ns1.pi-hole.net"
        remote_os_domain=${OS_CHECK_DOMAIN_NAME:-"versions.pi-hole.net"}

        detected_os=$(grep '^ID=' /etc/os-release | cut -d '=' -f2 | tr -d '"')
        detected_version=$(grep VERSION_ID /etc/os-release | cut -d '=' -f2 | tr -d '"')

        # Test via IPv4 and hardcoded nameserver ns1.pi-hole.net
        cmdResult=$(os_check_dig 4 "${remote_os_domain}" "${piholeNameserver}")

        # Gets the return code of the previous command (last line)
        digReturnCode="${cmdResult##*$'\n'}"

        if [ ! "${digReturnCode}" == "0" ]; then
            valid_response=false
        else
            valid_response=$(os_check_dig_response cmdResult)
        fi

        # Try again via IPv6 and hardcoded nameserver ns1.pi-hole.net
        if [ "$valid_response" = false ]; then
            unset valid_response
            unset cmdResult
            unset digReturnCode

            cmdResult=$(os_check_dig 6 "${remote_os_domain}" "${piholeNameserver}")
            # Gets the return code of the previous command (last line)
            digReturnCode="${cmdResult##*$'\n'}"

            if [ ! "${digReturnCode}" == "0" ]; then
                valid_response=false
            else
                valid_response=$(os_check_dig_response cmdResult)
            fi
        fi

        # Try again without hardcoded nameserver
        if [ "$valid_response" = false ]; then
            unset valid_response
            unset cmdResult
            unset digReturnCode

            cmdResult=$(os_check_dig 4 "${remote_os_domain}")
            # Gets the return code of the previous command (last line)
            digReturnCode="${cmdResult##*$'\n'}"

            if [ ! "${digReturnCode}" == "0" ]; then
                valid_response=false
            else
                valid_response=$(os_check_dig_response cmdResult)
            fi
        fi

        if [ "$valid_response" = false ]; then
            unset valid_response
            unset cmdResult
            unset digReturnCode

            cmdResult=$(os_check_dig 6 "${remote_os_domain}")
            # Gets the return code of the previous command (last line)
            digReturnCode="${cmdResult##*$'\n'}"

            if [ ! "${digReturnCode}" == "0" ]; then
                valid_response=false
            else
                valid_response=$(os_check_dig_response cmdResult)
            fi
        fi

        if [ "$valid_response" = true ]; then
            response="${cmdResult%%$'\n'*}"
            IFS=" " read -r -a supportedOS < <(echo "${response}" | tr -d '"')
            for distro_and_versions in "${supportedOS[@]}"; do
                distro_part="${distro_and_versions%%=*}"
                versions_part="${distro_and_versions##*=}"

                # If the distro part is a (case-insensitive) substring of the computer OS
                if [[ "${detected_os^^}" =~ ${distro_part^^} ]]; then
                    valid_os=true
                    IFS="," read -r -a supportedVer <<<"${versions_part}"
                    for version in "${supportedVer[@]}"; do
                        if [[ "${detected_version}" =~ $version ]]; then
                            valid_version=true
                            break
                        fi
                    done
                    break
                fi
            done
        fi

        if [ "$valid_os" = true ] && [ "$valid_version" = true ] && [ "$valid_response" = true ]; then
            display_warning=false
        fi

        if [ "$display_warning" != false ]; then
            if [ "$valid_response" = false ]; then

                if [ "${digReturnCode}" -eq 0 ]; then
                    errStr="dig succeeded, but response was blank. Please contact support"
                else
                    errStr="dig failed with return code ${digReturnCode}"
                fi
                printf "  %b %bRetrieval of supported OS list failed. %s. %b\\n" "${CROSS}" "${COL_LIGHT_RED}" "${errStr}" "${COL_NC}"
                printf "      %bUnable to determine if the detected OS (%s %s) is supported%b\\n" "${COL_LIGHT_RED}" "${detected_os^}" "${detected_version}" "${COL_NC}"
                printf "      Possible causes for this include:\\n"
                printf "        - Firewall blocking DNS lookups from Pi-hole device to ns1.pi-hole.net\\n"
                printf "        - DNS resolution issues of the host system\\n"
                printf "        - Other internet connectivity issues\\n"
            else
                printf "  %b %bUnsupported OS detected: %s %s%b\\n" "${CROSS}" "${COL_LIGHT_RED}" "${detected_os^}" "${detected_version}" "${COL_NC}"
                printf "      If you are seeing this message and you do have a supported OS, please contact support.\\n"
            fi
            printf "\\n"
            printf "      %bhttps://docs.pi-hole.net/main/prerequisites/#supported-operating-systems%b\\n" "${COL_LIGHT_GREEN}" "${COL_NC}"
            printf "\\n"
            printf "      If you wish to attempt to continue anyway, you can try one of the following commands to skip this check:\\n"
            printf "\\n"
            printf "      e.g: If you are seeing this message on a fresh install, you can run:\\n"
            printf "             %bcurl -sSL https://install.pi-hole.net | sudo PIHOLE_SKIP_OS_CHECK=true bash%b\\n" "${COL_LIGHT_GREEN}" "${COL_NC}"
            printf "\\n"
            printf "           If you are seeing this message after having run pihole -up:\\n"
            printf "             %bsudo PIHOLE_SKIP_OS_CHECK=true pihole -r%b\\n" "${COL_LIGHT_GREEN}" "${COL_NC}"
            printf "           (In this case, your previous run of pihole -up will have already updated the local repository)\\n"
            printf "\\n"
            printf "      It is possible that the installation will still fail at this stage due to an unsupported configuration.\\n"
            printf "      If that is the case, you can feel free to ask the community on Discourse with the %bCommunity Help%b category:\\n" "${COL_LIGHT_RED}" "${COL_NC}"
            printf "      %bhttps://discourse.pi-hole.net/c/bugs-problems-issues/community-help/%b\\n" "${COL_LIGHT_GREEN}" "${COL_NC}"
            printf "\\n"
            exit 1

        else
            printf "  %b %bSupported OS detected%b\\n" "${TICK}" "${COL_LIGHT_GREEN}" "${COL_NC}"
        fi
    else
        printf "  %b %bPIHOLE_SKIP_OS_CHECK env variable set to true - installer will continue%b\\n" "${INFO}" "${COL_LIGHT_GREEN}" "${COL_NC}"
    fi
}
