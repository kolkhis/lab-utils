#!/bin/bash
# shellcheck disable=SC2120

# Generate a list of destinations for bastion.sh
# Destination list based on a SSH config file (to be provided separately)


declare SSH_CONFIG_FILE
declare INPUT_FILE
declare OUTPUT_FILE='./destinations.txt'
declare VERBOSE=1

declare -a DESTINATIONS

debug() {
    (( VERBOSE )) || return 1
    [[ -n $# ]] && printf "[ \033[34mDEBUG\033[0m ]: %s\n" "$*" && return 0
    printf "[ \033[34mDEBUG\033[0m ]: "
}

warn() {
    [[ -n $# ]] && printf "[ \033[33mWARNING\033[0m ]: %s\n" "$*" && return 0
    printf "[ \033[33mWARNING\033[0m ]: "
}

err() {
    [[ -n $# ]] && printf >&2 "[ \032[33mERROR\033[0m ]: %s\n" "$*" && return 0
    printf >&2 "[ \033[32mERROR\033[0m ]: " && return 0
}



parse-args(){

    [[ -z $# ]] && debug "No args to parse." && return 0
    while [[ -n $1 ]]; do
        case $1 in
            -o|--output-file)
                { [[ -n $2 ]] && shift && OUTPUT_FILE=$1; } || {
                    err && printf >&2 "The -f/--OUTput-file argument was given but no file specified.\n" && return 1; } 
                printf "Outputting destinations to the file: %s\n" "$OUTPUT_FILE"
                shift;
                ;;
            -f|--input-file)
                { [[ -n $2 ]] && shift && INPUT_FILE=$1; } || {
                    err && printf >&2 "The -f/--input-file argument was given but no file specified.\n" && return 1; } 
                printf "Generating destinations based on the file: %s\n" "$INPUT_FILE"
                shift
                ;;
            -c|--config-file)
                { [[ -n $2 ]] && shift && SSH_CONFIG_FILE=$1; } || {
                    err && printf >&2 "The -c/--config-file argument was given but no file specified.\n" && return 1; }
                printf "Using SSH config file: %s\n" "$SSH_CONFIG_FILE"
                shift;
                ;;
            -h|--help)
                printf "Usage: ./generate-destinations [-c SSH_CONFIG_FILE] \n"
                exit 0;
                ;;
            *)
                printf "Unknown argument: %s\n" "$1"
                exit 1;
                ;;
        esac
    done

    return 0

}

parse-input-file() {
    : "This function is reserved for extending functionality in the future."
    : "Will allow for a custom input format."
}

parse-ssh-config(){
    # Parse the SSH config file
    #   - Output into more easily parsed file?
    #   - E.g., each line:
    #     user@hostname

    [[ -z $SSH_CONFIG_FILE || ! -f $SSH_CONFIG_FILE ]] && return 1
    
    local -a ENTRIES=()
    # awk '/^Host/ {printf "%s ", $2} /User/ {printf "%s@", $2} /Hostname/ {printf "%s\n", $2}' ~/.ssh/config
    mapfile -t ENTRIES < <(
        awk '/^Host/ {printf "%s ", $2} /User/ {printf "%s@", $2} /Hostname/ {printf "%s\n", $2}' "$SSH_CONFIG_FILE"
    )

    [[ "${#ENTRIES[@]}" -eq 0 ]] && err "Failed to parse file (parsed input is empty)\n" && return 1
    # ${ENTRIES[@]} contents (first column Host, then User@Hostname):
    # rocky streamer1@prolug.asuscomm.com
    # pve kolkhis@192.168.4.49
    # desmond kolkhis@192.168.4.53


    # - [x] TODO(validation): Use regex to check if each entry is formatted correctly
    # (e.g., user@hostname ) -- must be SSH-ready.
    # - [ ] TODO(feat): Number the lines. Allow user to either enter the number or the
    # 'Host' (not Hostname) to traverse to the machine

    for n in "${!ENTRIES[@]}"; do
        printf "entry number %s: %s\n" "$n" "${ENTRIES[$n]}";
        local parsed_destination
        parsed_destination=$(perl -ne 'print "$1 $2" if m/(\w+)\s*(\w+@\d{3}\.\d{3}\.\d{1,3}\.\d{1,3})/' <<< "${ENTRIES[$n]}")
        [[ -z $parsed_destination ]] && printf "Bad entry: %s\n " "${ENTRIES[$n]}" && continue
        debug "Parsed entry: $parsed_destination"
        DESTINATIONS=("${DESTINATIONS[@]}" "$parsed_destination")
    done


    while read -r line; do
        :
    done < "$SSH_CONFIG_FILE"

}

output-destinations(){
    printf "%s\n" "${DESTINATIONS[@]}"
}

main() {
    parse-args "$@" || {
        err "Failed to parse arguments!" && exit 1
    }

    if ! [[ -f ${SSH_CONFIG_FILE:=$HOME/.ssh/config} ]]; then
        err "There is no SSH config file at $SSH_CONFIG_FILE" 
        exit 1
    fi

    parse-ssh-config || {
        err "Failed to parse SSH config file!" && exit 1
    }

    output-destinations > "$OUTPUT_FILE"
}
main "$@"





