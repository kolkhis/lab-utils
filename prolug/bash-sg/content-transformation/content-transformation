#!/bin/bash
# shellcheck disable=SC2034,SC2016
























printf "Content Transformation Tools (Bash, Perl, sed, cut, AWK, and adjacent tools).\n"







































































printf "This talk assumes some knowledge (I have talked about all of these things).\n"

declare -a PREREQUISITES=(
    "pipelines and redirection"
    "regex"
    "parameter expansion"
)

printf "If at any point you don't understand something or have a question, stop me.\n"





















































printf "Let's talk about the tools first.\n"
printf "We will be primarily be using perl and sed (maybe a little bit of awk).\n"

printf "Sed and perl have some overlapping functionality.\n"
printf "But, there are things perl can do that sed cannot, and visa versa.\n"

printf "One of the most common use cases is performing substitutions.\n"
printf "I've shown these types of substitutions before but I've never really went indepth into how it works.\n"

    sed 's/old/new/' file.txt

printf "It's simple on the face of it: Match a pattern, replace it with something else.\n"
printf "There are modifiers we can add at the end (like 'g' for global, or 'i' for case-insensitive).\n"









































































printf "Let's look at this substitution.\n"

    echo "Match the word hello." | perl -pe 's/hello//'
    # Output: Match the word .

printf "This simply matches the word 'hello' and replaces it with nothing.\n"
printf "But what's happening here?\n"

printf "Doing a substutition or other one-liner with perl, we usually want to use the -pe options.\n"
printf "The '-p' wraps the input in a 'printing loop'. \
        Each line will print after being passed through the expression.\n"
printf "The '-e' specifies the expression.\n"

printf "Each line will be printed after being run through whatever code we put in the -e (expression).\n"

    echo "Match the word hello." | perl -pe 's/hello//'

printf "This is the default behavior in 'sed'.\n"

    echo "Match the word hello." | sed 's/hello//'
    # Output: Match the word .

printf "So basically, we'd use 'perl -pe' to make it behave like sed.\n"

























































printf "By default, 'sed' uses POSIX Basic Regular Expressions (BREs).\n"
printf "I went over this in the regex talk.\n"
printf "To recap, BREs require us to escape certin regex operators (e.g., capture groups).\n"

    echo "Capture hello and greet the user." | sed "s/.*\(hello\).*/\1, $USER./"
    # output: hello, kolkhis. 

printf 'Note the double quotes, needed for $USER to expand.\n'
printf "Typically we'll see 'sed' invoked with single quotes to avoid expansion, but we want it here.\n"

printf "Escaping regex characters is annoying, so we can enable Extended Regular Expresssions (EREs),"
printf "To enable EREs, use the -E option.\n"

    sed -E "s/.*(hello).*/\1, $USER./" <<< "Capture hello and greet the user."
    # output: hello, kolkhis.

printf "Now sed regex looks a little bit more like perl.\n"

printf "Side note: The -E is now POSIX-compliant.\n"


























































# Modifiers: s/old/new/X
printf "After the last '/' in a substitution command, we can add modifiers to change behavior.\n"
printf "A common one is 'g' (global), which performs the substitution on ALL matches.\n"

printf "Let's use a varible for this.\n"

    declare mystring="hello, replace hello with hi"

printf "The goal: Replace the word 'hello' with 'hi'.\n"
# Desired output: hi, replace hi with hi

    perl -pe 's/hello/hi/g' <<< "$mystring"
    sed 's/hello/hi/g' <<< "$mystring"

printf "Or, as shellcheck suggests, we can use a parameter expansion.\n"

    echo "${mystring/hello/hi}"   # Single replacement
    echo "${mystring//hello/hi}"  # Global modifier
    # output: hi, replace hi with hi

printf "Cool. But all of that is case sensitive.\n"
printf "Let's redefine that variable to have a capital Hello.\n"

    mystring="Hello, replace hello with hi"

    perl -pe 's/hello/hi/g' <<< "$mystring"
    sed 's/hello/hi/g' <<< "$mystring"
    # output: Hello, replace hi with hi

printf "We can use the 'i' modifier to make it case-insensitive.\n"

    perl -pe 's/hello/hi/gi' <<< "$mystring"
    sed 's/hello/hi/gi' <<< "$mystring"
    # output: hi, replace hi with hi




































































# in-place editing
printf "Now, if we're not using a pipe and we want to perform operations on files, we can.\n"
printf "Both perl and sed have a '-i' option to enable in-place editing of files.\n"

    cat ./examples/hello.c
    perl -pi -e 's/world/friend/g' ./examples/hello.c
    cat ./examples/hello.c

printf "So we replaced 'Hello, world.' with 'Hello, friend.'\n"
printf "If we didn't specify '-i', it would only output the change to stdout.\n"

printf "Now let's change it back with sed.\n"

    cat ./examples/hello.c
    sed -i 's/friend/world/g' ./examples/hello.c
    cat ./examples/hello.c

printf "Cool. But, what if we wanted to make a backup before we make any changes?\n"
printf "If this was a really important system file, or we're testing changes, we might want to make a backup.\n"

printf "That's built in to '-i'. Just add a suffix directly after the '-i' and it'll make a backup.\n"

    perl -pi.bak -e 's/world/friend/g' ./examples/hello.c
    sed -i.bak 's/world/friend/g' ./examples/hello.c

printf "This will create a 'examples/hello.c.bak' file, which is a backup of the original.\n"
printf "This is very useful if we're working with files that are not under version control.\n"

printf "To restore a file from its backup, just use 'mv'.\n"

    mv ./examples/hello.c.bak ./examples/hello.c

printf "Then our file is successfully restored.\n"








































































# Substituting only on matching lines
printf "Sometimes we only want to perform substitutions on lines that match a certain pattern.\n"
printf "Take this 'users.txt' for example:\n"

    cat ./examples/users.txt

printf "Say we want to change the role for 'eve' from 'guest' to 'admin'.\n"

    sed -i.bak '/\beve\b/s/guest/admin/' ./examples/users.txt
    sed -i.bak '/\beve\b/ s/admin/guest/' ./examples/users.txt
    # \< \> \b (word bounaries)
    printf "We use word boundaries here so we don't also match 'steve'.\n"

printf "Using sed, we specify a pattern (/eve/) BEFORE we put in the command (s///)\n"
printf "This will perform the command _only_ on the lines matching the pattern.\n"

printf "We can achieve this using perl too, in a bit of a different way.\n"

    perl -pi.bak -e 's/guest/admin/ if m/\beve\b/' ./examples/users.txt
    # Change it back:
    perl -pi.bak -e 's/admin/guest/ if m/\beve\b/' ./examples/users.txt

printf "We have a simple 'command if condition' here.\n"
printf "This leverages the fact that Perl is an actual entire programming language.\n"
printf "The 'm/pattern/' in Perl is just a way to match a pattern, and will return true if it matches.\n"

# Alternative: Capture groups
printf "We can also use capture groups instead of matching on a pattern.\n"

    perl -pi.bak -e 's/(user: eve, role: ).*/$1admin/' ./examples/users.txt
    # Change it back with sed
    sed -Ei 's/(user: eve, role: ).*/\1guest/' ./examples/users.txt 

printf "Although this is more explicit, I prefer the previous method for this purpose.\n"























































# Inserting and deleting
printf "So, we know how to do substitutions. That's fine. But there's more.\n"

printf "With sed, we can also insert lines and delete lines.\n"
printf "Let's add a new user to the 'users.txt' file above 'alice'.\n"

    cat ./examples/users.txt
    # user: alice, role: admin
    # user: bob, role: user
    # user: carol, role: admin
    # user: dave, role: user
    # user: eve, role: guest

    sed -i.bak '/alice/i user: aaron, role: user' ./examples/users.txt
    cat ./examples/users.txt

    # user: aaron, role: user
    # user: alice, role: admin
    # user: bob, role: user
    # user: carol, role: admin
    # user: dave, role: user
    # user: eve, role: guest

printf "This uses sed's 'i' command. It inserts a line above the lines matching a pattern.\n"

printf "We can also add lines AFTER a specific line using the 'a' command.\n"

    sed -i.bak '/\beve\b/a user: fred, role: admin' ./examples/users.txt
    cat ./examples/users.txt

    # user: aaron, role: user
    # user: alice, role: admin
    # user: bob, role: user
    # user: carol, role: admin
    # user: dave, role: user
    # user: eve, role: guest
    # user: fred, role: admin




























































# Inserting and deleting (cont)
printf "Now let's delete those entries we made.\n"

    sed 's/.*fred.*//' ./examples/users.txt
    sed -i.bak '/fred/d' ./examples/users.txt

printf "This just deletes any lines that match the pattern.\n"
printf "But we added multiple lines. Let's specify multiple patterns.\n"

    sed -i.bak -E '/(fred|aaron)/d' ./examples/users.txt
    cat ./examples/users.txt
    # user: alice, role: admin
    # user: bob, role: user
    # user: carol, role: admin
    # user: dave, role: user
    # user: eve, role: guest

printf "Here we use a capture group to specify two patterns. Match either 'fred' or 'aaron', and delete.\n"
printf "We used -E so that we did not have to escape the parentheses.\n"
































































# Delete lines with perl

printf "We can achieve a similar result using perl with the '-ne' options.\n"

    perl -ni.bak -e 'print $_ unless m/(fred|aaron)/' ./examples/users.txt
    perl -ni.bak -e 'print $_ if not m/(fred|aaron)/' ./examples/users.txt

printf "The '-n' option wraps the input in a non-printing loop.\n"
printf "Basically that means it will loop over the input, just like '-p', but it will not print it by defult.\n"

printf 'The $_ variable in Perl is the "default variable."\n'
printf "It holds the current line that is being processed.\n"
printf "So since it's in a non-printing loop, we tell it only to print if the line does not match the pattern.\n"

printf 'We could also just leave out the $_, as it is implied when calling print in this context.\n'

    perl -ne 'print unless m/(fred|aaron)/' ./examples/users.txt

    # Same as:
    perl -e 'while(<>) { print unless m/(fred|aaron)/ }' ./examples/users.txt

printf "That's how we can delete lines with perl.\n"
printf "It's a tiny bit more cumbersome (on us) than sed for this operation, but still works just fine.\n"



























































# Using cut, awk, and perl to print columns
printf "Commonly, we'll want to grab a specific field or column from text output.\n"
printf "For now, we'll talk about columns separated by whitespace.\n"

printf "There are a number of ways to do this. Most people reach for 'awk' first.\n"

    echo "One two three" | awk '{print $1}'
    # or, let's use a herestring (it's better, trust me)
    awk '{print $1}' <<< "One two three"

printf "A more lightweight option is to use 'cut'.\n"

    cut -d' ' -f1 <<< "One two three"

printf "Or... we can use perl!\n"

    perl -ae 'print "$F[0]\n"' <<< "One two three"

printf "The -a option turns on 'autosplit mode', which saves each field into the @F array.\n"

printf "We can also use the 'read' bash builtin.\n"

    IFS=' ' read -r -d '' col1 col2 col3 <<< "One two three"
    echo "$col1"

printf "The benefit of this method is that we save them into variables for later use.\n"

















































# Print columns separated by non-whitespace characters
printf "Not all data is separated by whitespace.\n"
printf "Take CSV, for example. These are comma-delimited fields of data.\n"
printf "We can use the same tools for this as well.\n"

    # Using awk
    echo "One,two,three" | awk -F, '{print $1}'

    # Using cut
    echo "One,two,three" | cut -d, -f1

    # Using read
    IFS=',' read -r col1 col2 col3 <<< "One,two,three"
    echo "$col1"

    # Using perl
    echo "One,two,three" | perl -F, -e 'print "$F[0]\n"'

printf "Notice we're not using -a here with perl. It's implied when using -F.\n"
printf "The -F option takes a delimiter, and uses that for -a (which is implicit).\n"




















































# Benchmarking the different options
printf "Let's put these to the test and see which method is most performant.\n"

    time for _ in {1..1000}; do echo "one,two,three" | perl -F, -e 'print "$F[0]\n"'; done
    # real    0m3.179s

    time for _ in {1..1000}; do echo "one,two,three" | awk -F, '{print $1}'; done
    # real    0m3.001s

    time for _ in {1..1000}; do echo "one,two,three" | cut -d, -f1; done
    # real    0m3.060s

printf "Cool! What if we used herestrings instead?\n"

    time for _ in {1..1000}; do perl -F, -e 'print "$F[0]\n"' <<< "one,two,three"; done
    # real    0m4.160s

    time for _ in {1..1000}; do awk -F, '{print $1}' <<< "one,two,three"; done
    # real    0m4.073s

    time for _ in {1..1000}; do cut -d, -f1 <<< "one,two,three"; done
    # real    0m3.432s

printf "Well this is interesting stuff.\n"


printf "We can use /usr/bin/time, which is a separate utility with more options.\n"
printf "Let's try comparing the echo pipe vs. the herestring method.\n"

    /usr/bin/time -f "Elapsed time: %e" bash -c 'for _ in {1..1000}; do echo "one,two,three" | perl -F, -e '\''print "$F[0]\n"'\''; done'
    # Elapsed: 2.94
    /usr/bin/time -f "Elapsed time: %e" bash -c 'for _ in {1..1000}; do perl -F, -e '\''print "$F[0]\n"'\'' <<< "one,two,three"; done'
    # Elapsed time: 3.52

    /usr/bin/time -f "Elapsed time: %e" bash -c 'for _ in {1..1000}; do awk -F, '\''{print $1}'\'' <<< "one,two,three"; done'
    # 2.26
    /usr/bin/time -f "Elapsed time: %e" bash -c 'for _ in {1..1000}; do echo "one,two,three" | awk -F, '\''{print $1}'\''; done'
    # 2.35

# TODO: Use hyperfine to benchmark all different options

    declare mystring="\"one,two,three\""
    declare perlcmd="perl -F, -e 'print \"\$F[0]\n\"' <<< $mystring"
    declare awkcmd="awk -F, '{print \$1}' <<< $mystring"
    declare cutcmd="cut -d, -f1 <<< $mystring"
    hyperfine "$perlcmd" "$awkcmd" "$cutcmd"



























































## TO BE CONTINUED


















































# Resources
man perlretut
man perlre
man sed
man awk 
man cut

printf "Questions?\n"
























































declare -a IDEAS=(
    "book project changes"
    "log filtering"
    "translating github flavored markdown to mkdocs flavored markdown"
)


