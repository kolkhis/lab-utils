#!/bin/bash























printf "Variables in Bash (and programming).\n"
























































printf "So what are variables?\n"

printf "Variables are, in a nutshell, containers for data.\n"
printf "You give them a name, and they store a value.\n"
































































# Creating variables
printf "Let's look at a very simple example of creating a variable in Bash:\n"

    MY_VAR=10

printf "This is what we call a variable assignment.\n"

printf "We're creating a variable by giving it a name (MY_VAR).\n"
printf "Then we're using the **assignment operator** (=) to assign it the value of 10.\n"










































































































# Using variables
printf "Now that we've seen how to create a variable, let's actually use one.\n"

    echo "$MY_VAR"
    # output: 10

printf 'We just use $ (dollar sign) and then the variable name.\n'
printf "This 'expands' to the value stored in MY_VAR (10).\n"

printf "Note that I'm using double-quotes around that variable.\n"

printf "You should *always* double-quote your variables.\n"

printf "It will technically work if you do not include quotes at all:\n"
    
    echo $MY_VAR

printf "However, this can cause word splitting and leaves you open to shell injection attacks.\n"

printf "So: ALWAYS QUOTE YOUR VARIABLES! \n"














































































# types
printf "In Bash, variables are **dynamically typed** by default, meaning they can store any type of data.\n"

    # Storing a number
    MY_VAR=10
    # Reassigning to a string
    MY_VAR="New value!"

printf "This makes working with variables in bash very easy. You don't need to worry about types.\n"
printf "Everything is basically a string of text.\n"

printf "If you have a number in a variable, Bash will allow you to do number stuff with it.\n"
printf 'Bash will "detect" that the value is a number.\n'

    MY_VAR=10
    (( MY_VAR++ ))
    echo "$MY_VAR" # 11

printf "The double parens (( ... )) are how you perform arithmetic operations in bash.\n"
printf 'You do not need to prefix your variable name with a dollar sign ($) in this context.\n'
printf "Now, if the value of MY_VAR is a string, this operation will error out.\n"

    MY_VAR="new value!"
    (( MY_VAR++ )) # error

printf "So just be mindful of this. If you're using a var for a number, keep it as a number.\n"














































































# Creating variables (declare)

printf "Now, yes, we can simply say 'VAR=value' and Bash will create the variable for us.\n"

printf "If we want to be more explicit, we can use the 'declare' builtin.\n"

    declare MY_VAR 
    typeset MY_VAR  # Synonym for `declare`

printf "This will create the variable, but will not assign any value to it.\n"

printf "This is known as 'initializing' a variable.\n"






























































# Scope
# Functions (local/declare in fns)

printf "By default, variables in bash are **globally-scoped**.\n"
printf "What does that mean?\n" 

printf "They can be accessed anywhere in the script (e.g., in functions, 'if' statements, etc.).\n"

    # Exported vars (subshells)
    printf "If you're using a subshell, you won't have access to the variable unless you export it.\n"
    printf "More on this later.\n"

printf "An exception to this is when using 'local' or 'declare' inside a function.\n"

    myfunc(){
        local private_var='hello'
        declare private_var2='world'
        echo "$private_var"  # hello
        echo "$private_var2" # world
    }
    echo "$private_var"  # No output
    echo "$private_var2" # No output

cat << EOF
Both of these variables are **locally-scoped** to the function.
They can only be used inside the function itself.
If you try to access them outside the function, you won't get anything (unless there's
    a global variable with the same name)
EOF



































# Variable attributes (declare [-i, -a, -A])





























# Exporting Variables
printf "If you need a variable to be available in child processes and subshells, you must export it.\n"

printf "There are a few ways to do this.\n"  

    declare MY_VAR
    export MY_VAR

printf "First we initialize the variable, then we export it using the 'export' builtin.\n"

printf "We can also use the -x option for 'declare'.\n"

    declare -x MY_VAR

printf "This both initializes and exports the variable.\n"














































