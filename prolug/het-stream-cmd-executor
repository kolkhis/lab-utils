#!/bin/bash
# shellcheck disable=SC2120
shopt -s extquote

declare WATCH_FILE="/data/stream_write/stream_answers"

declare -a EXCLUDE_KEYWORDS=(
    'rm -rf /'
    '-Rf'
    'rm --recursive'
    'rm -R'
    'rm -f'
    'rm --force'
    '--no-preserve-root'
    'cat /dev/urandom'
    'cat /dev/random'
    '/dev/random'
    '/dev/urandom'
    'virsh'
    ':(){:|:&}'
    '\x1b['
    '\033['
    '\e['
    '\u001b['
    'reboot'
    'shutdown'
)

declare -A COLORS=(
    [red]=$'\033[31m'
    [green]=$'\033[32m'
    [yellow]=$'\033[33m'
    [reset]=$'\033[0m'
)

warn() {
    [[ $# -gt 0 ]] && printf "[ %sWARNING%s ]: %s\n" "${COLORS[yellow]}" "${COLORS[reset]}" "$*" && return 0
    printf "[ %sWARNING%s ]: " "${COLORS[yellow]}" "${COLORS[reset]}"
}

err() {
    [[ $# -gt 0 ]] && printf "[ %sERROR%s ]: %s\n" "${COLORS[red]}" "${COLORS[reset]}" "$*" && return 0
    printf "[ %sERROR%s ]: " "${COLORS[red]}" "${COLORS[reset]}" 
}

debug() {
    if [[ $VERBOSE -gt 0 ]]; then
        [[ $# -gt 0 ]] && printf '[ DEBUG ]: %s\n' "$*"
        [[ $# -eq 0 ]] && printf '[ DEBUG ]: '
    fi
}

is-forkbomb() {
    local cmd=
    local parsed=
    [[ -z $1 ]] && printf "No input provided to function!\n" && return 0
    cmd="$1"
    parsed=$(
        perl -ne 'print $1 if m/(.{1,}\s*\(\s*\)\s*[{]\s*.{1,}\s*[|]\s*.{1,}\s*&\s*[}]).*/' <<< "$cmd"
    )

    # printf "Parsed command: %s\n" "$parsed"
    [[ -z $parsed ]] && return 1
    [[ -n $parsed ]] && printf "Forkbomb detected in '%s' -- This part: %s\n" \
        "${COLORS[red]}${cmd}${COLORS[reset]}" \
        "${COLORS[green]}${parsed}${COLORS[reset]}" && return 0
}


is-malicious-cmd() {
    local cmd
    [[ -z $1 ]] && printf "No input provided to function!\n" && return 0
    cmd="$1"
    is-forkbomb "$cmd" && return 0

    if [[ "${EXCLUDE_KEYWORDS[*]}" =~ ${cmd} ]]; then
        warn; printf "Illegal command: %s\n" "$cmd"
        return 0
    fi

    if [[ $cmd =~ ([[:cntrl:]]+) ]]; then
        warn; printf "Illegal character(s) found in command %s: %s\n" "$cmd" "${BASH_REMATCH[1]}" 
        return 0
    fi

    # extra layer for control seqs
    for EX in "${EXCLUDE_KEYWORDS[@]}"; do
        if [[ $cmd =~ ${EX} ]]; then
            warn; printf "Illegal substring found in command %s: %s\n" "$cmd" "$EX"
            return 0
        fi
    done
    return 1
}


main() {
    # Follow the tail of $WATCH_FILE
    while read -r line; do

        IFS=':' read -r user source command <<< "$line"

        printf "User: %s answered on %s. Their command is: %s\n" \
                "${COLORS[green]}${user}${COLORS[reset]}" \
                "${COLORS[green]}${source}${COLORS[reset]}" \
                "${COLORS[yellow]}${command}${COLORS[reset]}"

        # Select a server to use
        num=$(( (RANDOM % 5) + 15 ))
        printf "Using server: rocky%s\n" "$num"

        sleep 2

        # Check connectivity
        if ! ping -c 1 "rocky$num" > /dev/null 2>&1; then
            err; printf "The server 'rocky%d' is unreachable!\n" "$num"
            continue
        fi

        # skip if user is a douchebag
        if is-malicious-cmd "$command"; then
            printf "Nice try, %s\n" "${COLORS[red]}${user}${COLORS[reset]}"
            continue
        fi

        # Execute the command
        timeout 15 ssh -i /root/.ssh/cluster_key rocky$num "timeout 15 $command"

    done < <(tail -F "$WATCH_FILE")
}

main || {
    err; printf >&2 "Script encountered an error! Exiting.\n" && exit 1;
}

